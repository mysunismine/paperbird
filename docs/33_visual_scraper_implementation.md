# Реализация визуального конструктора парсеров (Visual Scraper)

Идея заключается в создании no-code/low-code инструмента, который позволит пользователям без навыков программирования настраивать парсинг новостных сайтов через интерактивный веб-интерфейс. Система на основе действий пользователя (кликов и выделений) будет автоматически генерировать конфигурационный JSON-файл (пресет), совместимый с существующей архитектурой (`presets/*.json`).

## Концепция и Архитектура

Основной интерфейс должен состоять из трех компонентов:

1.  **Окно предпросмотра (`<iframe>`):** Отображает целевой сайт, с которым взаимодействует пользователь.
2.  **Панель управления:** UI-элементы для выбора типа данных, которые пользователь хочет извлечь (заголовок, контент, ссылка и т.д.).
3.  **Бэкенд-генератор:** Серверный компонент, который получает от фронтенда CSS-селекторы выделенных элементов и формирует из них готовый JSON-пресет.

---

## Детальный план реализации

### Часть 1: Фронтенд (Интерактивный UI)

Это самая сложная и важная часть.

1.  **Создание интерфейса:**
    *   Поле для ввода URL сайта.
    *   Большой `<iframe>`, в котором будет загружаться введенный URL.
    *   Панель управления с кнопками, соответствующими полям в JSON-пресете:
        *   Для `list_page`: "Выделить список новостей", "Найти ссылку в элементе списка".
        *   Для `article_page`: "Выделить заголовок", "Выделить контент", "Выделить изображения", "Выделить дату публикации" и т.д.
        *   Кнопка "Сохранить пресет".

2.  **Логика "инспектора" элементов:**
    *   Приложение входит в режим "выбора", когда пользователь нажимает одну из кнопок на панели управления (например, "Выделить заголовок").
    *   JavaScript-код отслеживает события мыши (`mouseover` и `click`) внутри `<iframe>`.
    *   При наведении мыши элемент подсвечивается, чтобы пользователь видел, что он собирается выбрать.
    *   При клике скрипт генерирует **стабильный CSS-селектор** для этого элемента. Это ключевая задача, требующая анализа DOM-дерева на предмет `id`, `class` или других уникальных атрибутов. Можно использовать готовые библиотеки, например, `css-selector-generator`.

3.  **Процесс работы пользователя (workflow):**

    *   **Шаг 1: Настройка страницы списка (`list_page`).**
        *   Пользователь вводит URL.
        *   В режиме "Выделить список новостей" кликает на один из элементов. Скрипт должен обобщить селектор, чтобы он подходил ко всем элементам списка (например, из `div.items > div:nth-child(3)` сделать `div.items > div`). Этот селектор сохранится для `list_page.selectors.items`.
        *   Далее в режиме "Найти ссылку" кликает на заголовок-ссылку внутри блока для получения селектора `list_page.selectors.url`.

    *   **Шаг 2: Переход на страницу статьи.**
        *   Система автоматически переходит по одной из найденных ссылок для загрузки полной новости в `<iframe>`.

    *   **Шаг 3: Настройка страницы статьи (`article_page`).**
        *   Пользователь последовательно выбирает заголовок, контент, изображения и другие элементы, а система сохраняет соответствующие CSS-селекторы.

    *   **Шаг 4: Генерация и проверка.**
        *   При нажатии "Сохранить" фронтенд отправляет на бэкенд JSON-объект с маппингом полей на селекторы.

### Часть 2: Бэкенд (Генератор пресетов)

1.  **API-эндпоинт:**
    *   Создается эндпоинт (например, `/api/generate-preset`), принимающий POST-запрос с данными от фронтенда.

2.  **Логика генератора:**
    *   Бэкенд формирует JSON-структуру, полностью идентичную файлам в `presets/`, на основе полученных данных.

3.  **Валидация "на лету" (рекомендуется):**
    *   Перед сохранением бэкенд выполняет тестовый парсинг с новой конфигурацией.
    *   Результаты (например, "Найдено 10 новостей, заголовок: '...'") отображаются пользователю для немедленной проверки.
    *   Этот шаг может потребовать headless-браузер (Playwright, Puppeteer) для сайтов, требующих выполнения JavaScript.

4.  **Сохранение:**
    *   После успешной валидации бэкенд сохраняет сгенерированный JSON в директорию `presets/`.

### Технические сложности и пути их решения

1.  **Безопасность и `<iframe>`:** Многие сайты запрещают встраивание через заголовок `X-Frame-Options`.
    *   **Решение:** Использовать серверный прокси. Бэкенд скачивает HTML, внедряет в него скрипт-инспектор и отдает фронтенду.

2.  **Генерация надежных селекторов:** Это самая сложная часть.
    *   **Решение:** Комбинировать стратегии (поиск по `id`, классам, `data-*` атрибутам) и дать пользователю возможность ручного редактирования селектора.

3.  **Динамические сайты (SPA):** Если контент загружается через JavaScript, простой загрузки HTML недостаточно.
    *   **Решение:** Использование headless-браузеров (Playwright/Puppeteer) на бэкенде для "отрисовки" страницы.